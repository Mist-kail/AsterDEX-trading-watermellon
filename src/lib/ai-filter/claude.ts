/**
 * Claude Decision Engine
 * Uses Claude Sonnet 4 to make approve/veto decisions on trade signals
 */

import { LLMClient } from "@blockrun/llm";
import type { SyntheticBar } from "../types";
import type { FilterDecision, SentimentResult, TradeSignalContext } from "./types";
import { formatSentimentForDecision } from "./grok";

const DECISION_MODEL = "anthropic/claude-sonnet-4";

const DECISION_PROMPT_TEMPLATE = `You are an expert crypto futures trading signal filter. Your job is to review trade signals generated by a technical analysis strategy and decide whether to APPROVE or VETO the trade.

## YOUR ROLE
- The technical strategy (EMA crossovers + ADX trend filter) has generated a signal
- You act as a "second opinion" to filter out potentially bad trades
- Be conservative: when in doubt, VETO
- Only APPROVE if the signal aligns with both price action AND sentiment

## TRADE SIGNAL
Direction: {{DIRECTION}}
Token: {{TOKEN}}
Entry Price: {{ENTRY_PRICE}}
Signal Reason: {{SIGNAL_REASON}}

## RECENT PRICE ACTION (last 5 bars)
{{PRICE_BARS}}

## LIVE SENTIMENT FROM X/TWITTER
{{SENTIMENT}}

## DECISION CRITERIA
APPROVE if:
- Sentiment supports the trade direction (bullish for long, bearish for short)
- Price action shows momentum in the signal direction
- No conflicting signals in recent bars

VETO if:
- Sentiment strongly conflicts with trade direction
- Price action shows reversal signs
- Market appears choppy or uncertain
- High confidence bearish sentiment for a long, or vice versa

## RESPONSE FORMAT
Respond in this EXACT format (no extra text):
DECISION: [APPROVE/VETO]
REASONING: [2-3 sentences explaining why]`;

export async function getDecision(
  client: LLMClient,
  context: TradeSignalContext,
  sentiment: SentimentResult
): Promise<FilterDecision> {
  const prompt = buildDecisionPrompt(context, sentiment);

  const response = await client.chat(DECISION_MODEL, prompt);

  return parseDecisionResponse(response);
}

function buildDecisionPrompt(
  context: TradeSignalContext,
  sentiment: SentimentResult
): string {
  const { signal, bar, token, recentBars } = context;

  const priceBarsText = formatRecentBars(recentBars);
  const sentimentText = formatSentimentForDecision(sentiment);

  return DECISION_PROMPT_TEMPLATE
    .replace("{{DIRECTION}}", signal.type.toUpperCase())
    .replace("{{TOKEN}}", token)
    .replace("{{ENTRY_PRICE}}", bar.close.toFixed(4))
    .replace("{{SIGNAL_REASON}}", signal.reason)
    .replace("{{PRICE_BARS}}", priceBarsText)
    .replace("{{SENTIMENT}}", sentimentText);
}

function formatRecentBars(bars: SyntheticBar[]): string {
  if (bars.length === 0) {
    return "No recent bar data available";
  }

  return bars
    .map((bar, i) => {
      const change = ((bar.close - bar.open) / bar.open) * 100;
      const direction = change >= 0 ? "+" : "";
      const time = new Date(bar.endTime).toISOString().slice(11, 19);
      return `[${i + 1}] ${time} | O:${bar.open.toFixed(2)} H:${bar.high.toFixed(2)} L:${bar.low.toFixed(2)} C:${bar.close.toFixed(2)} | ${direction}${change.toFixed(2)}%`;
    })
    .join("\n");
}

function parseDecisionResponse(response: string): FilterDecision {
  const lines = response.trim().split("\n");

  let approved = false;
  let reasoning = "Unable to parse decision reasoning";

  for (const line of lines) {
    const trimmed = line.trim();

    if (trimmed.startsWith("DECISION:")) {
      const value = trimmed.replace("DECISION:", "").trim().toUpperCase();
      approved = value === "APPROVE";
    } else if (trimmed.startsWith("REASONING:")) {
      reasoning = trimmed.replace("REASONING:", "").trim();
    }
  }

  return {
    approved,
    reasoning,
  };
}
